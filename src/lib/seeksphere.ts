import { SeeksphereSearchResult, Property } from './types';

// Import seeksphere SDK
let SeekSphereClient: any;
try {
  const sdk = require('seeksphere-sdk');
  SeekSphereClient = sdk.SeekSphereClient;
} catch (error) {
  console.warn('Seeksphere SDK not available:', error);
}

// Seeksphere configuration
const seeksphereConfig = {
  apiKey: process.env.SEEKSPHERE_API_KEY,
  timeout: 30000,
};

// Global seeksphere client instance
let seeksphereClient: any = null;

/**
 * Initialize seeksphere client
 */
const initializeClient = () => {
  if (!SeekSphereClient) {
    throw new Error('Seeksphere SDK not available - please install seeksphere-sdk package');
  }

  if (!seeksphereConfig.apiKey) {
    throw new Error('Seeksphere API key not configured - please set SEEKSPHERE_API_KEY environment variable');
  }

  if (!seeksphereClient) {
    try {
      seeksphereClient = new SeekSphereClient({
        apiKey: seeksphereConfig.apiKey,
        timeout: seeksphereConfig.timeout,
      });
    } catch (error) {
      throw new Error(`Failed to initialize Seeksphere client: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  return seeksphereClient;
};

/**
 * Search using seeksphere - just pass the query string directly
 */
export const searchWithSeeksphere = async (
  query: string,
  page: number = 1,
  limit: number = 20
): Promise<SeeksphereSearchResult> => {
  const startTime = Date.now();

  try {
    // Check if seeksphere is available first
    if (!isSeeksphereAvailable()) {
      throw new Error('Seeksphere service is not available');
    }

    const client = initializeClient();

    // Use seeksphere to convert natural language to SQL
    const searchResult = await client.search({
      query: query
    }, 'sql_only');

    // Execute the generated SQL query against our database
    const properties = await executeSeeksphereSQL(searchResult);

    const searchTime = Date.now() - startTime;

    return {
      properties,
      total: properties.length,
      page,
      limit,
      filters: { query },
      relevance_scores: [],
      search_time_ms: searchTime,
      suggestions: [],
      sql_query: searchResult.sql_query || '',
      seeksphere_response: searchResult,
    };
  } catch (error) {
    console.error('Error searching with seeksphere:', error);
    
    // Graceful degradation - fall back to traditional search
    const fallbackResult = await fallbackToTraditionalSearch(query, page, limit);
    
    return {
      ...fallbackResult,
      search_time_ms: Date.now() - startTime,
      error: error instanceof Error ? error.message : 'Seeksphere search failed',
      fallback_used: true,
    };
  }
};

/**
 * Fallback to traditional search when seeksphere fails
 */
const fallbackToTraditionalSearch = async (
  query: string,
  page: number,
  limit: number
): Promise<SeeksphereSearchResult> => {
  try {
    const { searchProperties, createPaginationParams } = await import('./database');
    
    const pagination = createPaginationParams(page, limit);
    const filters = { query };
    const sort = { field: 'date' as const, direction: 'desc' as const };
    
    const result = await searchProperties(filters, pagination, sort);
    
    return {
      properties: result.properties,
      total: result.total,
      page: result.page,
      limit: result.limit,
      filters: { query },
      relevance_scores: [],
      suggestions: [],
    };
  } catch (fallbackError) {
    console.error('Fallback search also failed:', fallbackError);
    return {
      properties: [],
      total: 0,
      page,
      limit,
      filters: { query },
      relevance_scores: [],
      suggestions: [],
    };
  }
};

/**
 * Execute the SQL query generated by seeksphere
 */
const executeSeeksphereSQL = async (searchResult: any): Promise<Property[]> => {
  try {
    const { query } = await import('./database');

    if (!searchResult.success) {
      console.warn('Seeksphere search failed:', searchResult.error || 'Unknown error');
      return [];
    }

    if (!searchResult.sql_query) {
      console.warn('No SQL query generated by seeksphere');
      return [];
    }

    console.log('Generated SQL:', searchResult.sql_query);

    // Execute the SQL query
    const result = await query(searchResult.sql_query);

    // Get full property objects
    const { getPropertyById } = await import('./database');
    const properties: Property[] = [];

    for (const row of result.rows) {
      if (row.id) {
        const property = await getPropertyById(row.id);
        if (property) {
          properties.push(property);
        }
      }
    }

    return properties;
  } catch (error) {
    console.error('Error executing seeksphere SQL:', error);
    return [];
  }
};

/**
 * Get search suggestions based on query
 */
export const getSearchSuggestions = async (query: string): Promise<string[]> => {
  try {
    if (!query.trim()) {
      return [];
    }

    const client = initializeClient();

    // Use seeksphere to get suggestions
    const result = await client.getSuggestions({
      query: query.trim(),
      limit: 5
    });

    return result.suggestions || [];
  } catch (error) {
    console.error('Error getting search suggestions:', error);
    
    // Fallback to basic suggestions
    return generateFallbackSuggestions(query);
  }
};

/**
 * Generate fallback suggestions when seeksphere is not available
 */
const generateFallbackSuggestions = (query: string): string[] => {
  const suggestions: string[] = [];
  const lowerQuery = query.toLowerCase();

  // Basic property type suggestions
  if (lowerQuery.includes('house') || lowerQuery.includes('home')) {
    suggestions.push('Modern house with garage');
    suggestions.push('Family home near schools');
  }
  
  if (lowerQuery.includes('condo') || lowerQuery.includes('apartment')) {
    suggestions.push('Downtown condo with parking');
    suggestions.push('Luxury apartment with amenities');
  }

  // Location-based suggestions
  if (lowerQuery.includes('downtown') || lowerQuery.includes('city')) {
    suggestions.push('Downtown properties with transit access');
  }

  // Feature-based suggestions
  if (lowerQuery.includes('parking') || lowerQuery.includes('garage')) {
    suggestions.push('Properties with parking included');
  }

  return suggestions.slice(0, 5);
};

/**
 * Check if seeksphere is properly configured and available
 */
export const isSeeksphereAvailable = (): boolean => {
  try {
    return !!SeekSphereClient && !!seeksphereConfig.apiKey;
  } catch (error) {
    return false;
  }
};

export { seeksphereConfig };